	I use select() to deal with i/o multiplexing, and use fcntl() to protect muti-servers. I think the hardest part of the program is how to control reading data from client such that i/o won't be blocked by one client. To solve it, it is necessary to use select() to monitor clients. If A client can read, then use handle_read() to check whether the data length is larger than 0. If it does, then we can do the commands as spec. If not, keep checking the next client. However, locks on item_list must be checked whenever reading or writing. Since fcntl() provides advisory lock and one process shares the same lock, I use fcntl() and wait_for_write to check whether the item_list can be written. 
	There was a bug when doing this homework. I open item_list with O_RDONLY when it's a read server. Then when I use fcntl() with F_GETLK to check whether there is a write lock on the specified item, it always locks. To solve the problem, I change O_RDONLY to O_RDWR and then the read server can work. I think it is because when opening the file with O_RDONLY , we cannot check whether there is a write lock on it.
